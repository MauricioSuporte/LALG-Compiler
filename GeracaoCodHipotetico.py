#carrega constante k no topo da pilha D
def CRCT(k):
    return

#carrega valor de endereço n no topo da pilha D
def CRVL(n):
    return

#soma o elemento antecessor com o topo da pilha
def SOMA():
    return

#subtrai o antecessor pelo elemento do topo
def SUBT():
    return

#multiplica elemento antecessor pelo elemento do topo
def MULT():
    return

#divide o elemento antecessor pelo elemento do topo
def DIVI():
    return

#inverte sinal do topo
def INVE():
    return

#conjunção de valores lógicos. F=0; V=1
def CONJ():
    return

#disjunção de valores lógicos
def DISJ():
    return

#negação lógica
def NEGA():
    return

#comparação de menor entre o antecessor e o topo
def CPME():
    return

#comparação de maior
def CPMA():
    return

#comparação de igualdade
def CPIG():
    return

#comparação de desigualdade
def CDES():
    return

#comparação menor-igual
def CPMI():
    return

#comparação maior-igual
def CMAI():
    return

#armazena o topo da pilha no endereço n de D
def ARMZ(n):
    return

#desvio incondicional para a instrução de endereço p
def DSVI(p):
    return

#desvio condicional para a instrução de endereço p; o desvio será
#executado caso a condição resultante seja falsa; o valor da
#condição estará no topo
def DSVF(p):
    return

#lê um dado de entrada para o topo da pilha
def LEIT():
    return

#imprime valor o valor do topo da pilha na saída
def IMPR():
    return

#reserva m posições na pilha D; m depende do tipo da variável
def ALME(m):
    return

#inicia programa – será sempre a 1ª instrução
def INPP():
    return

#termina a execução do programa
def PARA():
    return